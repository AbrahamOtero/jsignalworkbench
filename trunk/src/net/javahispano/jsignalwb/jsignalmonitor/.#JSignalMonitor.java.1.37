package net.javahispano.jsignalwb.jsignalmonitor;

import javax.swing.JPanel;

/**
 * <p>Componente ligero de Swing que permite representar la evolución temporal de
 * un conjunto de señales mostradas, así como una serie de marcas relacionadas
 * con dichas señales. Las señales y marcas que el componente representa son
 * proporcionadas por un objeto {@link JSignalMonitorDataSource}. El usuario
 * interacciona directamente con JSignalMonitor y éste solicitará a su fuente de
 * datos la información que necesita para visualizar en pantalla los datos que
 * haya requerido el usuario a través de sus interacciones. </p>
 *
 *<p> JSignalMonitor
 * también puede notificar al {@link JSignalMonitorDataSource} sobre ciertas
 * acciones realizadas por el usuario, como la selección de un fragmento de
 * señal o la creación o borrado de marcas. El objeto proporciona un {@link
 * Grid} por defecto, {@link DefaultGrid}, que puede ser reemplazado para cada
 * canal empleando métodos de esta interfaz. Las marcas que JSignalMonitor puede
 * representar también pueden extenderse. </p>
 *
 * <p>Para obtener el panel donde JSignalMonitor representará toda la información
 * relativa a las señales debe emplearse el método getJSignalMonitorPanel. No se
 * recomiende interaccionar con el panel que devuelve ese método directamente;
 * cualquier interacción con JSignalMonitor debería realizarse a través de esta
 * clase.</p>
 *
 * @author Román Segador y Abraham Otero Copyright 2006-2007. This software is
 *   under the Apache License Version 2.0 (http://www.apache.org/licenses/).
 */
public class JSignalMonitor {
    //private JSignalMonitorDataSource jsm;
    private static int index=10;
    private JSignalMonitorPanel jsmPanel;
    private JSMProperties jsmProperties;


    /**
     * crea una instancia de JSignalMonitor con el {@link
     * JSignalMonitorDataSource}que se le pasa como argumento.
     *
     * @param jSignalMonitorDataSource {@link JSignalMonitorDataSource}
     */
    public JSignalMonitor(JSignalMonitorDataSource jSignalMonitorDataSource) {
        this.jsmProperties=new JSMProperties(jSignalMonitorDataSource);
        jsmPanel=new JSignalMonitorPanel(jsmProperties);
        System.out.println(index++);
    }

    public void addModeListener(JSignalMonitorModeListener l){
        jsmProperties.addModeListener(l);
    }
    public void addScrollValueListener(JSignalMonitorScrollListener l){
        jsmProperties.addScrollValueChangeListener(l);
    }
    /**
     * Añade un canal que visualizará la señal cuyo nombre se le pasa como parámetro.
     * Se visualizara con las propiedades de visualizacion que se le pasan como
     * segundo parametro.
     *
     * @param signalName nombre de la señal.
     * @param {@link ChannelProperties} propiedades de visualizacion del canal.
     * @return true si la acción se realizó correctamente, false en caso
     *   contrario.
     */
    public boolean addChannel(String name,ChannelProperties properties){
        return this.addChannel(new Channel(name,properties));
    }

    private boolean addChannel(Channel c){
        if(jsmPanel.addChannel(c)){
            refreshMaxMinTime();
            repaintAll();
            return true;
        }
        return false;
    }

    /**
     *  Metodo encargado de refrescar el valor minimo y maximo representados
     *  por {@link JSignalMonitor} en la escala del tiempo.
     */
    private void refreshMaxMinTime(){
        long minTime=-1;
        long maxTime=-1;
        ChannelProperties cp;
        for(String name:jsmPanel.getChannels().getChannelNames()){
            cp=getChannelProperties(name);
            if(cp.getStartTime()<minTime ||minTime<0)
                minTime=cp.getStartTime();
            if(cp.getEndTime()>maxTime)
                maxTime=cp.getEndTime();
        }
        jsmProperties.setScrollBaseTime(minTime);
        jsmProperties.setMaxTime(maxTime);
    }

    /**
     * Establece el zoom vertical en tanto por ciento. Un zoom de 100 mostrará
     * la señal original sin ninguna amplificación o reducción. Un zoom de 50,
     * por ejemplo, mostrará el valor de la señal original dividido entre dos, y
     * uno de 200 el doble del valor de la señal original.
     *
     * @param signalName nombre de la señal a la cual se va a cambiar el zoom.
     * @param value nuevo zoom.
     */
    public void setVerticalZoom(String signalName,int value){
        jsmPanel.setVerticalZoom(signalName,value);
    }
    /**
     * Obtiene el zoom vertical en tanto por ciento. Un zoom de 100 mostrará
     * la señal original sin ninguna amplificación o reducción. Un zoom de 50,
     * por ejemplo, mostrará el valor de la señal original dividido entre dos, y
     * uno de 200 el doble del valor de la señal original.
     *
     * @param signalName nombre de la señal de la cual se va a obtener el zoom.
     * @return  zoom.
     */
    public int getVerticalZoom(String signalName){
        return jsmPanel.getVerticalZoom(signalName);
    }

    /**
     * Devuelve el número de canales que se están representando.
     *
     * @return int
     * @todo  http://en.wikipedia.org/wiki/Law_of_Demeter
     */
    public int channelsSize(){
        return jsmPanel.getChannelsSize();
    }

    /**
     * Permite averiguar en qué canal se está visualizando una determinada señal.
     * el primer canal es el 0.
     *
     * @param channelName nombre de la señal.
     * @return número del canal.
     */
    public int getChannelPosition(String channelName){
        return jsmPanel.getChannelPosition(channelName);
    }

    /**
     * Permite averiguar en qué canal se está visualizando una determinada señal.
     * El primer canal es el 0.
     *
     * @param index número de canal.
     * @return Nombre de la señal que se está visualizando.
     */
    public String getChannelName(int index){
        return jsmPanel.getChannelAtIndex(index);
    }

    /**
     * Intercambia las posiciones de los canales correspondientes con las
     * señales que se le pasan como argumentos.
     *
     * @param channel1 nombre de la primera señal.
     * @param channel2 nombre de la segunda señal.
     */
    public void swapChannelsPositions(String channel1,String channel2){
        jsmPanel.swapChannelsPositions(channel1,channel2);
    }

    /**
     * obtiene el objeto {@link ChannelProperties} correspondiente con el canal
     * en el que se representa la señal que se le pasa como argumento.
     *
     * @param channelName nombre de la señal.
     * @return {@link ChannelProperties} correspondiente a la señal que se le
     *   pasó como argumento.
     */
    public ChannelProperties getChannelProperties(String channelName){
        return jsmPanel.getChannelProperties(channelName);
    }

    /**
     * Deja de mostrar la señal que se le pasa como parámetro, eliminando el
     * canal por completo de {@link JSignalMonitor}.
     *
     * @param signalName nombre de la señal.
     * @return true si la acción se realizó correctamente, false en caso
     *   contrario.
     */
    public boolean removeChannel(String signalName) {

        boolean flag=jsmPanel.removeChannel(signalName);
        refreshMaxMinTime();
        repaintAll();
        return flag;
    }

    /**
     * comprobar si existe un canal asociado con el nombre que se le pasa como
     * argumento.
     *
     * @param channelName String
     * @return true si existe el canal, fase en caso contrario.
     */
    public boolean hasChannel(String channelName){
        return jsmPanel.hasChannel(channelName);
    }

    /**
     * Elimina todos los canales que se estaban mostrando.
     */
    public void removeAllChannels(){
        jsmPanel.resetChannels();
        this.repaintAll();
    }

    /**
     * Fuerza un repintado de los canales. Se volverán a solicitar los datos a
     * representar al {@link JSignalMonitorDataSource}.
     */
    public void repaintChannels() {
        jsmPanel.refreshData();
    }

    /**
     * Fuerza un repintado de los canales y refrescar los paneles que se sitúan
     * a la izquierda de JSignalMonitor muestran informacion sobre las
     * señales, asi como los valores representado en el scrollBar.
     * Se volverán a solicitar los datos a representar al {@link
     * JSignalMonitorDataSource}.
     */
    public void repaintAll() {
        refreshMaxMinTime();
        jsmPanel.refresh();
    }

    /**
     * Devuelve el panel en el cual JSignalMonitor representará toda la
     * información. Este será el panel que debe añadirse a la ventana o Applet
     * donde se quiera emplear JSignalMonitor.
     *
     * @return JPanel
     */
    public JPanel getJSignalMonitorPanel(){
        return jsmPanel;
    }

    /**
     * Modifica el {@link JSignalMonitorDataSource}de esta instancia de
     * JSignalMonitor.
     *
     * @param jsmds JSignalMonitorDataSource
     */
    public void setJSMDataSource(JSignalMonitorDataSource jsmds){
        jsmProperties.setDataSource(jsmds);
    }

    /**
     * modifica el tiempo base del scroll y, por tanto, el tiempo base que
     * emplea JSignalMonitor. No se representaran instantes de tiempo anteriores
     * a este instante.
     *
     * @param baseTime tiempo base del scroll medido en milisegundos.  Ver
     *   {@link TimePositionConverter}.
     */
    public void setScrollBaseTime(long baseTime){
        jsmProperties.setScrollBaseTime(baseTime);
    }

    /**
     * Obtiene el {@link JSignalMonitorDataSource}asociado con esta instancia de
     * JSignalMonitor.
     *
     * @return JSignalMonitorDataSource
     */
    public JSignalMonitorDataSource getJSMDataSource(){
        return jsmProperties.getDataSource();
    }

    /**
     * Modifica el tiempo máximo que será visualizado por JSignalMonitor. Para
     * JSignalMonitor este instante del tiempo es el final del registro de
     * señal y no se mostraran instantes de tiempo posteriores a el.
     *
     * @param maxTime Instante de tiempo medido en milisegundos.  Ver {@link TimePositionConverter}.
     */
    public void setEndTime(long maxTime){
        jsmProperties.setMaxTime(maxTime);
    }

    /**
     * Modifica el instante de tiempo a cual está apuntando el scroll. Debe estar
     * contenido entre los limites del scroll.ver {@link getScrollBaseTime} y
     * {@link getEndTime}.
     *
     * @param scrollValue instante de tiempo al cual va a pasar a apuntar el
     *   scroll metido en milisegundos.  Ver {@link TimePositionConverter}.
     */
    public void setScrollValue(long scrollValue){
        if(scrollValue<getScrollBaseTime())
            scrollValue=getScrollBaseTime();
        else if(scrollValue>(jsmProperties.getMaxTime()-getVisibleTime()))
            scrollValue=(jsmProperties.getMaxTime()-getVisibleTime());
        jsmProperties.setScrollValue(scrollValue);
    }

    /**
     * Modifica la frecuencia de representación de JSignalMonitor. Aunque las
     * distintas señales que esté visualizando JSignalMonitor tengan distinta
     * frecuencia un corte vertical sobre todos los ejes temporales que
     * representa JSignalMonitor se corresponde siempre a un mismo instante del
     * tiempo. Para ello, JSignalMonitor emplea una frecuencia ficticia de
     * representación, que podría coincidir con la de alguna o todas las
     * señales. Dicha frecuencia ficticia de representación se modifica a través
     * de este método.
     *
     * @param frecuency Frecuencia de representación de JSignalMonitor.
     */
    public void setFrecuency(float frecuency){
        jsmProperties.setFrec(frecuency);
    }

    /**
     * Devuelve el tiempo base del scroll representado en milisegundos. Ver
     * {@link TimePositionConverter}.
     *
     * @return long
     */
    public long getScrollBaseTime(){
        return jsmProperties.getScrollBaseTime();
    }

    /**
     * Devuelve el instante de fin del registro representado en milisegundos.
     * Ver {@link TimePositionConverter}.
     *
     * @return long
     */
    public long getEndTime(){
        return jsmProperties.getMaxTime();
    }

    /**
     * Devuelve el instante de tiempo al cual está apuntando el scroll
     * representado en milisegundos. Ver {@link TimePositionConverter}.
     *
     * @return long
     */
    public long getScrollValue(){
        return jsmProperties.getScrollValue();
    }

    /**
     * Devuelve la frecuencia ficticia de representación de JSignalMonitor. Ver
     *  setFrecuency()
     *
     * @return float
     */
    public float getFrecuency(){
        return jsmProperties.getFrec();
    }

    /**
     * Indica si se deben de representar los valores (x, y) de las señales al
     * mover el ratón sobre ellas.
     *
     * @param rep true si se deben pintar los valores, false en caso contrario.
     */
    public void setRepresentingXYValues(boolean rep){
        jsmProperties.setRepresentingValues(rep);
        jsmPanel.setXYInfoPanelVisible(rep);

    }

    /**
     * Indica si se están representando los valores (x, y) de las señales.
     *
     * @return true si se están representando, false en caso contrario.
     */
    public boolean isRepresentingXYValues(){
        return jsmProperties.isRepresentingValues();
    }

    /**
     * Si se le pasa el valor true ordena a JSignalMonitor que comience la
     * selección de un intervalo de señal; si se le pasa el valor false se
     * detiene la selección del intervalo.
     *
     * @param value boolean
     */
    public void setSelectIntervalMode(boolean value){
        if(value)
            jsmProperties.setMarkCreation(false);
        jsmProperties.setIntervalSelection(value);
        if(value)
            repaintChannels();
    }

    /**
     * Indica si se está procediendo actualmente a la selección de un intervalo
     * de señal.
     *
     * @return true en caso afirmativo, false en caso negativo.
     */
    public boolean isSelectIntervalMode(){
        return jsmProperties.isIntervalSelection();
    }

    /**
     * Si se le pasa el valor true ordena a JSignalMonitor que comience la
     * creaccion de marcas en las señales; si se le pasa el valor false se
     * detiene la creacion. Si el parametro es true y {@link isSelectIntervalMode()}
     * devolvia el valor true, este pasara a devolver el valor false.
     *
     * @param value boolean
     */
    public void setMarksSelectionMode(boolean value){
         jsmProperties.setMarkCreation(value);
         repaintChannels();
    }

    /**
     * Indica si se está procediendo actualmente a la creacion de marcas en las
     * señales.
     *
     * @return true en caso afirmativo, false en caso negativo.
     */

    public boolean isMarkSelectionMode(){
        return jsmProperties.isMarkCreation();
    }
    /**
     * Devuelve el alto, medido en píxeles, de cada uno de los canales.
     *
     * @return int
     */
    public int getChannelHeight(){
        return jsmPanel.getChannelHeight();
    }

    public JSignalMonitorGrid getChannelGrid(String channelName){
        return jsmPanel.getChannelGrid(channelName);
    }

    public void setChannelGrid(String channelName,JSignalMonitorGrid jsmGrid){
        jsmPanel.setChannelGrid(channelName,jsmGrid);
    }
    public JSMProperties getJSMProperties(){
        return jsmProperties;
    }
    public long getVisibleTime(){
        return jsmPanel.getVisibleTime();
    }
}
